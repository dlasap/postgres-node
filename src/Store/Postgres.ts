import SimpleStore from "./Simple";
import {
  Message,
  PostgresStoreConfig,
  StoreItem,
  StoreAccessCollectionParameters,
  StoreAccessItemParameters,
  StoreAccessByFilterParameters,
  StoreAccessByIndexParameters,
  SystemQueryOperations,
  SystemUpdateOperations,
  StoreAccessOperations,
  ISingleFilterCriteriaRequest,
  ISearchParams,
} from "../types";
import {
  Client,
  Client as PostgresClient,
  ClientConfig,
  // PoolConfig,
  Pool,
  PoolConfig,
} from "pg";
import createLogger from "../../utils/logger";
import { getCode } from "./utils/system_code";
import { omit } from "lodash";
import {
  getPostgresInsertQuery,
  getPostgresUpdateQuery,
  getPostgresFilterQuery,
  createPostgresTableQuery,
} from "../../utils/helper";
import { throws } from "assert";
const logger = createLogger("store:postgresSQL");

/**
 * * POSTGRESQL ORM for CRDT.
 * * Usage: new PostgresdbStore(config as PostgresdbStoreConfig)
 @class RedisStore
 @extends SimpleStore
 @param {object} config typeof RedisStoreConfig
*/
class PostgresStore
  extends SimpleStore
  implements
    SystemQueryOperations,
    SystemUpdateOperations,
    StoreAccessOperations
{
  pg: PostgresClient;
  config: ClientConfig;
  pool: any;
  constructor({ transport, message_store, config }: PostgresStoreConfig) {
    super({ transport, message_store });
    this.config = config;
    this.pg = new PostgresClient(omit(config, ["database"]));
    this.pool = new Pool({
      ...omit(config, ["database"]),
      idleTimeoutMillis: 0,
      connectionTimeoutMillis: 0,
    });
  }

  async initialize() {
    super.initialize();
    logger.info(`Postgres Store Initialized`);
  }
  async createDBClient(database?: string): Promise<PostgresClient> {
    let config = this.config;
    if (database)
      config = {
        ...config,
        database,
      };
    const client = new PostgresClient(config);
    await client.connect();
    return client;
  }

  async createPoolClient(database?: string): Promise<Pool> {
    let config = {
      ...this.config,
      idleTimeoutMillis: 0,
      connectionTimeoutMillis: 0,
    };
    if (database) config = { ...config, database };
    const pool = new Pool(config);
    await pool.connect();
    return pool;
  }

  async applyCreateDatabase(database: string, options?: any): Promise<void> {
    try {
      const query = `CREATE DATABASE ${database}`;
      await this.pool.connect();
      await this.pool.query(query);
      this.pool.end();
    } catch (e: any) {
      logger.error(e.message);
    }
    return;
  }

  async applyCreateTable(
    database: string,
    table: string,
    options?: any
  ): Promise<void> {
    const client = await await this.createDBClient(database);
    try {
      const fields_schema = await createPostgresTableQuery(options);

      //for system_code related fields
      const default_system_code_fields =
        "system_company_id uuid, system_code json, system_id text";

      const query = `
      CREATE TABLE IF NOT EXISTS "${database}-${table}" 
      (${fields_schema},${default_system_code_fields});
      `;

      await client.query(query);

      await client.end();
    } catch (e: any) {
      logger.error(e.message);
      await client.end();
    }
  }

  //!-TODO
  async applyCreateIndex(
    database: string,
    dataset: string,
    column: string
  ): Promise<void> {
    try {
      const client = await this.createDBClient(database);
      const query = `
      CREATE INDEX index_name 
      ON table_name(column_name);`;
      await client.query(query);
      await client.end();
    } catch (e: any) {
      logger.error(e.message);
    }
  }
  async applyUpdate(msg: Message) {
    const {
      database,
      dataset,
      row: id,
      column,
      value,
      system_id = "",
      entity_fields = {},
    } = msg;
    const client = await this.createDBClient(database);
    try {
      const db_table_name = database + "-" + dataset;
      const row = (await this.getById({
        id,
        database,
        dataset,
      })) as StoreItem;

      const isExisting = Object.keys(row).length;

      //!DISABLED-autogenerated code
      // let code = await getCode({
      //   system_id,
      //   column,
      //   value,
      //   system_code: value,
      // });
      // let code = "TESTING";\
      let code = "";

      const update_params =
        isExisting && column === "tombstone" && value === 1
          ? {
              id,
              tombstone: 1,
              status: "Deleted",
              version: row!.version + 1,
              updated_date: new Date().getTime(),
            }
          : {
              ...entity_fields,
              system_id,
              ...(code && { code }),
              id,
            };

      if (!isExisting) {
        const { fields, set_values, values } = await getPostgresInsertQuery(
          update_params
        );

        const insert_query = `
        INSERT INTO "${db_table_name}"
        (${fields.toString()})
        VALUES (${set_values})
        `;

        await client.query(insert_query, values);
      } else {
        const { set_query, values } = await getPostgresUpdateQuery(
          update_params
        );

        const update_query = `
        UPDATE "${db_table_name}"
        SET ${set_query}
        WHERE id=$${values.length + 1}
        `;

        await client.query(update_query, [...values, update_params.id]);
      }
      await client.end();
      return;
    } catch (error) {
      logger.error(`[APPLY UPDATE ERROR]: `, error);
      await client.end();
    }
  }

  async listDatabases(): Promise<string[]> {
    const pool = await this.createDBClient();
    try {
      const query = `
      SELECT datname FROM pg_database
      WHERE datistemplate = false;
      `;
      const databases = await pool
        .query(query)
        .then(({ rows }: Record<string, any>) =>
          rows.map(({ datname }: Record<string, any>) => datname)
        );
      await pool.end();

      return databases;
    } catch (error: any) {
      console.log("List Database Error: ", error);
      await pool.end();
      return [];
    }
  }

  async listTables(database: string): Promise<string[]> {
    const client = await this.createDBClient(database);
    try {
      const query = `
      SELECT tablename
      FROM pg_catalog.pg_tables
      WHERE schemaname != 'pg_catalog' AND 
      schemaname != 'information_schema';
      `;

      const tables = await client
        .query(query)
        .then(({ rows }) =>
          rows.map(({ tablename }) => tablename).filter(Boolean)
        );

      await client.end();
      return tables;
    } catch (err: any) {
      logger.log(err);
      await client.end();
      return [];
    }
  }

  // async listIndex(database: string, dataset: string): Promise<string[]> {
  //   return this.r.db(database).table(dataset).indexList().run();
  // }

  /*
    When accessing data, you can still query them as is with the exception of filtering out tombstones.
  */
  async getById(params: StoreAccessItemParameters): Promise<StoreItem | null> {
    const { database, dataset, id } = params;
    const client = await this.createDBClient(database);
    try {
      const {
        rows: [result],
      } = await client?.query(
        `SELECT * FROM "${database}-${dataset}" WHERE id=$1 AND tombstone=0`,
        [id]
      );
      await client.end();
      return result || {};
    } catch (error) {
      logger.error(`[GET BY ID ERROR]: ${error}`);
      await client.end();
      return {} as unknown as StoreItem;
    }
  }

  async list(params: StoreAccessCollectionParameters): Promise<StoreItem[]> {
    const { database, dataset, order } = params;
    const { limit = 50, start = 0, order_key, order_directions } = order ?? {};

    const client = await this.createDBClient(database);

    let query = `SELECT * FROM "${database}-${dataset}" LIMIT ${limit} OFFSET ${start}`;

    if (!!order_directions && !!order_key) {
      query = `
      SELECT * FROM "${database}-${dataset}" ORDER BY ${order_key} 
      ${order_directions === "ASCENDING" ? "ASC" : "DESC"}
      LIMIT ${limit} OFFSET ${start}
      `;
    }
    const { rows } = await client.query(query);
    await client.end();
    return rows;
  }
  // async getByIndex(
  //   params: StoreAccessByIndexParameters<any>
  // ): Promise<StoreItem[]> {
  //   const { database, dataset, order, indexes } = params;
  //   const { limit, start, order_key, order_directions } = order;

  //   const index = Object.keys(indexes);

  //   if (index.length == 0) {
  //     return this.list(params);
  //   }

  //   if (index.length !== 1) {
  //     return this.getByFilter({
  //       ...params,
  //       filters: indexes,
  //     });
  //   }

  //   const index_name = index[0];
  //   const index_value = indexes[index_name];

  //   let query = this.r
  //     .db(database)
  //     .table(dataset)
  //     .getAll(index_value, { index: index_name })
  //     .filter({
  //       tombstone: 0,
  //     });

  //   if (!!order_directions && !!order_key) {
  //     query.orderBy(
  //       order_directions === "ASCENDING"
  //         ? this.r.asc(order_key)
  //         : this.r.desc(order_key)
  //     );
  //   }

  //   return query.skip(start).limit(limit).run() as unknown as Promise<
  //     StoreItem[]
  //   >;
  // }
  async getByFilter(
    params: StoreAccessByFilterParameters<any>
  ): Promise<StoreItem[]> {
    const { database, dataset, order, filters } = params ?? {};
    const client = await this.createDBClient(database);
    const { limit = 50, start = 0, order_key, order_directions } = order ?? {};
    try {
      const db_table_name = `${database}-${dataset}`;
      let query = `
      SELECT * FROM "${db_table_name}"
      WHERE ${await getPostgresFilterQuery({ ...filters, tombstone: 0 })}
      LIMIT ${limit} OFFSET ${start}
      `;
      if (!!order_directions && !!order_key) {
        query = `
        SELECT * FROM "${db_table_name}"
        WHERE ${await getPostgresFilterQuery({ ...filters, tombstone: 0 })}
        ORDER BY ${order_key} ${
          order_directions === "ASCENDING" ? "ASC" : "DESC"
        }
        LIMIT ${limit} OFFSET ${start}
        `;
      }
      const { rows } = await client.query(query);
      await client.end();
      return rows as unknown as Promise<StoreItem[]>;
    } catch (error: any) {
      console.log("GETBYFILTER ERROR : ", error.stack);
      await client.end();
      return [];
    }
  }

  async getBySingleFilter(
    params: ISingleFilterCriteriaRequest
  ): Promise<StoreItem[]> {
    return [];
  }

  async search(params: ISearchParams): Promise<StoreItem[]> {
    throw new Error("Search Not Implemented");
    return [];
  }
}

export default PostgresStore;
